//
//  main.m
//  Task3
//
//  Created by Anton Kostenko on 25.07.15.
//  Copyright (c) 2015 Anton Kostenko. All rights reserved.
//

//Задание 7.
//Условие:
//Есть иерархия из задания 6.
//Задание:
//1. Бухгалтер и директор на предприятии один и просто синхронизированы на выполнение одной операции за раз (бухгалтер считает деньги одного рабочего, остальные ждут)
//2. Переделать код так, чтобы выполнение операций обработки выполнялось бухгалтерами и мойщиками через performSelectorInBackground в бекграундном потоке с последующей нотификацией наблюдателей в главной потоке через performSelectorOnMainThread;
//3. Каждая из асинхронных операций должна выполняцца разное время (через вызов sleep(n) внутри блока);
//4. Надо учесть то, что у нас есть проблема с тем, что сразу из нескольких потоков может модифицировацца массив наблюдателей, что приведет к падению, дял избежания создать потокобезопасный наблюдаемый объект с синхронизацией, отвечающий следующим требованиям:
//а. может происходить только одна операция с внутренним мутабельным массивом за раз, будь то копирование, добавление или чтение объекта;
//б. должен быть абстрактным базовым классом, который мы уже в детях расширяем поведением;
//в. поскольку он ничего не знает о том, какие именно методы будут использовацца для нотификаций в детях, необходимо придумать метод, который бы давал универсальную возможность для нотификации с использованием разных методов (т.е. надо передавать селектор, используемый для нотификаций);
//г. надо придумать еще один метод, как обертку дял метода из в., который бы перед нотификациями синхронным образом переходил в главный поток и оттуда производил нотификации;
//5. Создать контролирующий класс, который бы занимался управлением автомойкой, т.е. следил (через наблюдение) за тем, кто из рабочих освободился и передавал ему следующую машину для мытья. Контроллер работает следующим образом:
//а. получил из разных потоков количество машин большее, чем количество мойщиков;
//б. передал машины мойщикам, а остальные машины стоят в очереди на мытье;
//в. наблюдает за всеми мойщиками;
//г. когда мойщик закончил мытье, то необходимо ему передать следующую машину на мытье.
//д. должен быть потокобезопасным с точки зрения управления мойщиками и очередью машин;
//6. Сгенерировать протокол следующих состояний мойщика и бухгалтера:
//а. готов к работе
//б. работает
//в. нуждается в обработке
//7. Поток денег идет следующим образом:
//- мойщик получил машину;
//- мойщик помыл машину;
//- мойщик забрал деньги у авто;
//- мойщик сообщил наблюдателям, что завершил работу;
//- бухгалтер наблюдает за мойщиком;
//- когда бухгалтер узнал, что мойщик помыл машину, то забрал у мойщика деньги;
//- мойщик сообщил наблюдателям, что готов к новой работе;
//- бухгалтер посчитал деньги и сообщил директору, что завершил работу;
//- директор сделал профит.
//8. вся логика переходов между потоками реализована в родительском классе работник;
//- необходимо создать такую логику переходов, чтобы:
//а. наличествовали методы, доступные для перегрузки, которые бы всегда выполнялись в бекграунде и главном потоке;
//б. эти методы должны быть обернуты в приватные методы, которые и обсепечивают логику переходов между потоками;
//в. по окончании обработки и переходе в главный поток сам работник должен сообщать наблюдателям, что он закончил работу;
//- в детях должна быть реализована только сама логика обработки данных на главном и бекграундном потоке, но не должно происходить перехода из потока в поток, т.к. все это должно быть реализовано в родительском классе





#import <Foundation/Foundation.h>

#import "WashTest.h"


int main(int argc, const char * argv[]) {
    @autoreleasepool {
        // insert code here...
        NSLog(@"Hello, World!");
        [WashTest cashFlowTest];
    }
    return 0;
}
